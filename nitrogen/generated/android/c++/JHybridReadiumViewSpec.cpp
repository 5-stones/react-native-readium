///
/// JHybridReadiumViewSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#include "JHybridReadiumViewSpec.hpp"

// Forward declaration of `ReadiumFile` to properly resolve imports.
namespace margelo::nitro::readium { struct ReadiumFile; }
// Forward declaration of `Locator` to properly resolve imports.
namespace margelo::nitro::readium { struct Locator; }
// Forward declaration of `LocatorLocations` to properly resolve imports.
namespace margelo::nitro::readium { struct LocatorLocations; }
// Forward declaration of `LocatorText` to properly resolve imports.
namespace margelo::nitro::readium { struct LocatorText; }
// Forward declaration of `Preferences` to properly resolve imports.
namespace margelo::nitro::readium { struct Preferences; }
// Forward declaration of `DecorationGroup` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationGroup; }
// Forward declaration of `Decoration` to properly resolve imports.
namespace margelo::nitro::readium { struct Decoration; }
// Forward declaration of `DecorationStyle` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationStyle; }
// Forward declaration of `SelectionAction` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionAction; }
// Forward declaration of `PublicationReadyEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct PublicationReadyEvent; }
// Forward declaration of `Link` to properly resolve imports.
namespace margelo::nitro::readium { struct Link; }
// Forward declaration of `PublicationMetadata` to properly resolve imports.
namespace margelo::nitro::readium { struct PublicationMetadata; }
// Forward declaration of `Accessibility` to properly resolve imports.
namespace margelo::nitro::readium { struct Accessibility; }
// Forward declaration of `AccessibilityCertification` to properly resolve imports.
namespace margelo::nitro::readium { struct AccessibilityCertification; }
// Forward declaration of `Contributor` to properly resolve imports.
namespace margelo::nitro::readium { struct Contributor; }
// Forward declaration of `Subject` to properly resolve imports.
namespace margelo::nitro::readium { struct Subject; }
// Forward declaration of `BelongsTo` to properly resolve imports.
namespace margelo::nitro::readium { struct BelongsTo; }
// Forward declaration of `SeriesInfo` to properly resolve imports.
namespace margelo::nitro::readium { struct SeriesInfo; }
// Forward declaration of `DecorationActivatedEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationActivatedEvent; }
// Forward declaration of `Rect` to properly resolve imports.
namespace margelo::nitro::readium { struct Rect; }
// Forward declaration of `Point` to properly resolve imports.
namespace margelo::nitro::readium { struct Point; }
// Forward declaration of `SelectionEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionEvent; }
// Forward declaration of `SelectionActionEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionActionEvent; }

#include "ReadiumFile.hpp"
#include <optional>
#include "JReadiumFile.hpp"
#include <string>
#include "Locator.hpp"
#include "JLocator.hpp"
#include "LocatorLocations.hpp"
#include "JLocatorLocations.hpp"
#include "LocatorText.hpp"
#include "JLocatorText.hpp"
#include "Preferences.hpp"
#include "JPreferences.hpp"
#include "DecorationGroup.hpp"
#include <vector>
#include "JDecorationGroup.hpp"
#include "Decoration.hpp"
#include "JDecoration.hpp"
#include "DecorationStyle.hpp"
#include "JDecorationStyle.hpp"
#include <unordered_map>
#include "SelectionAction.hpp"
#include "JSelectionAction.hpp"
#include <functional>
#include "JFunc_void_Locator.hpp"
#include <NitroModules/JNICallable.hpp>
#include "PublicationReadyEvent.hpp"
#include "JFunc_void_PublicationReadyEvent.hpp"
#include "JPublicationReadyEvent.hpp"
#include "Link.hpp"
#include "JLink.hpp"
#include "PublicationMetadata.hpp"
#include "JPublicationMetadata.hpp"
#include "Accessibility.hpp"
#include "JAccessibility.hpp"
#include "AccessibilityCertification.hpp"
#include "JAccessibilityCertification.hpp"
#include "Contributor.hpp"
#include "JContributor.hpp"
#include "Subject.hpp"
#include "JSubject.hpp"
#include "BelongsTo.hpp"
#include "JBelongsTo.hpp"
#include "SeriesInfo.hpp"
#include "JSeriesInfo.hpp"
#include "DecorationActivatedEvent.hpp"
#include "JFunc_void_DecorationActivatedEvent.hpp"
#include "JDecorationActivatedEvent.hpp"
#include "Rect.hpp"
#include "JRect.hpp"
#include "Point.hpp"
#include "JPoint.hpp"
#include "SelectionEvent.hpp"
#include "JFunc_void_SelectionEvent.hpp"
#include "JSelectionEvent.hpp"
#include "SelectionActionEvent.hpp"
#include "JFunc_void_SelectionActionEvent.hpp"
#include "JSelectionActionEvent.hpp"

namespace margelo::nitro::readium {

  jni::local_ref<JHybridReadiumViewSpec::jhybriddata> JHybridReadiumViewSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridReadiumViewSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridReadiumViewSpec::initHybrid),
    });
  }

  size_t JHybridReadiumViewSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  bool JHybridReadiumViewSpec::equals(const std::shared_ptr<HybridObject>& other) {
    if (auto otherCast = std::dynamic_pointer_cast<JHybridReadiumViewSpec>(other)) {
      return _javaPart == otherCast->_javaPart;
    }
    return false;
  }

  void JHybridReadiumViewSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  std::string JHybridReadiumViewSpec::toString() {
    static const auto method = javaClassStatic()->getMethod<jni::JString()>("toString");
    auto javaString = method(_javaPart);
    return javaString->toStdString();
  }

  // Properties
  std::optional<ReadiumFile> JHybridReadiumViewSpec::getFile() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JReadiumFile>()>("getFile");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setFile(const std::optional<ReadiumFile>& file) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JReadiumFile> /* file */)>("setFile");
    method(_javaPart, file.has_value() ? JReadiumFile::fromCpp(file.value()) : nullptr);
  }
  std::optional<Locator> JHybridReadiumViewSpec::getLocation() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JLocator>()>("getLocation");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setLocation(const std::optional<Locator>& location) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JLocator> /* location */)>("setLocation");
    method(_javaPart, location.has_value() ? JLocator::fromCpp(location.value()) : nullptr);
  }
  std::optional<Preferences> JHybridReadiumViewSpec::getPreferences() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPreferences>()>("getPreferences");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setPreferences(const std::optional<Preferences>& preferences) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JPreferences> /* preferences */)>("setPreferences");
    method(_javaPart, preferences.has_value() ? JPreferences::fromCpp(preferences.value()) : nullptr);
  }
  std::optional<std::vector<DecorationGroup>> JHybridReadiumViewSpec::getDecorations() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JDecorationGroup>>()>("getDecorations");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<DecorationGroup> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setDecorations(const std::optional<std::vector<DecorationGroup>>& decorations) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JDecorationGroup>> /* decorations */)>("setDecorations");
    method(_javaPart, decorations.has_value() ? [&]() {
      size_t __size = decorations.value().size();
      jni::local_ref<jni::JArrayClass<JDecorationGroup>> __array = jni::JArrayClass<JDecorationGroup>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = decorations.value()[__i];
        auto __elementJni = JDecorationGroup::fromCpp(__element);
        __array->setElement(__i, *__elementJni);
      }
      return __array;
    }() : nullptr);
  }
  std::optional<std::vector<SelectionAction>> JHybridReadiumViewSpec::getSelectionActions() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JSelectionAction>>()>("getSelectionActions");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<SelectionAction> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setSelectionActions(const std::optional<std::vector<SelectionAction>>& selectionActions) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JSelectionAction>> /* selectionActions */)>("setSelectionActions");
    method(_javaPart, selectionActions.has_value() ? [&]() {
      size_t __size = selectionActions.value().size();
      jni::local_ref<jni::JArrayClass<JSelectionAction>> __array = jni::JArrayClass<JSelectionAction>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = selectionActions.value()[__i];
        auto __elementJni = JSelectionAction::fromCpp(__element);
        __array->setElement(__i, *__elementJni);
      }
      return __array;
    }() : nullptr);
  }
  std::optional<std::function<void(const Locator& /* locator */)>> JHybridReadiumViewSpec::getOnLocationChange() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_Locator::javaobject>()>("getOnLocationChange_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const Locator& /* locator */)> {
      if (__result->isInstanceOf(JFunc_void_Locator_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_Locator_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return JNICallable<JFunc_void_Locator, void(Locator)>(std::move(__resultRef));
      }
    }()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setOnLocationChange(const std::optional<std::function<void(const Locator& /* locator */)>>& onLocationChange) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_Locator::javaobject> /* onLocationChange */)>("setOnLocationChange_cxx");
    method(_javaPart, onLocationChange.has_value() ? JFunc_void_Locator_cxx::fromCpp(onLocationChange.value()) : nullptr);
  }
  std::optional<std::function<void(const PublicationReadyEvent& /* event */)>> JHybridReadiumViewSpec::getOnPublicationReady() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_PublicationReadyEvent::javaobject>()>("getOnPublicationReady_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const PublicationReadyEvent& /* event */)> {
      if (__result->isInstanceOf(JFunc_void_PublicationReadyEvent_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_PublicationReadyEvent_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return JNICallable<JFunc_void_PublicationReadyEvent, void(PublicationReadyEvent)>(std::move(__resultRef));
      }
    }()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setOnPublicationReady(const std::optional<std::function<void(const PublicationReadyEvent& /* event */)>>& onPublicationReady) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_PublicationReadyEvent::javaobject> /* onPublicationReady */)>("setOnPublicationReady_cxx");
    method(_javaPart, onPublicationReady.has_value() ? JFunc_void_PublicationReadyEvent_cxx::fromCpp(onPublicationReady.value()) : nullptr);
  }
  std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>> JHybridReadiumViewSpec::getOnDecorationActivated() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_DecorationActivatedEvent::javaobject>()>("getOnDecorationActivated_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const DecorationActivatedEvent& /* event */)> {
      if (__result->isInstanceOf(JFunc_void_DecorationActivatedEvent_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_DecorationActivatedEvent_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return JNICallable<JFunc_void_DecorationActivatedEvent, void(DecorationActivatedEvent)>(std::move(__resultRef));
      }
    }()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setOnDecorationActivated(const std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>& onDecorationActivated) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_DecorationActivatedEvent::javaobject> /* onDecorationActivated */)>("setOnDecorationActivated_cxx");
    method(_javaPart, onDecorationActivated.has_value() ? JFunc_void_DecorationActivatedEvent_cxx::fromCpp(onDecorationActivated.value()) : nullptr);
  }
  std::optional<std::function<void(const SelectionEvent& /* event */)>> JHybridReadiumViewSpec::getOnSelectionChange() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_SelectionEvent::javaobject>()>("getOnSelectionChange_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const SelectionEvent& /* event */)> {
      if (__result->isInstanceOf(JFunc_void_SelectionEvent_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_SelectionEvent_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return JNICallable<JFunc_void_SelectionEvent, void(SelectionEvent)>(std::move(__resultRef));
      }
    }()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setOnSelectionChange(const std::optional<std::function<void(const SelectionEvent& /* event */)>>& onSelectionChange) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_SelectionEvent::javaobject> /* onSelectionChange */)>("setOnSelectionChange_cxx");
    method(_javaPart, onSelectionChange.has_value() ? JFunc_void_SelectionEvent_cxx::fromCpp(onSelectionChange.value()) : nullptr);
  }
  std::optional<std::function<void(const SelectionActionEvent& /* event */)>> JHybridReadiumViewSpec::getOnSelectionAction() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_SelectionActionEvent::javaobject>()>("getOnSelectionAction_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const SelectionActionEvent& /* event */)> {
      if (__result->isInstanceOf(JFunc_void_SelectionActionEvent_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_SelectionActionEvent_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return JNICallable<JFunc_void_SelectionActionEvent, void(SelectionActionEvent)>(std::move(__resultRef));
      }
    }()) : std::nullopt;
  }
  void JHybridReadiumViewSpec::setOnSelectionAction(const std::optional<std::function<void(const SelectionActionEvent& /* event */)>>& onSelectionAction) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_SelectionActionEvent::javaobject> /* onSelectionAction */)>("setOnSelectionAction_cxx");
    method(_javaPart, onSelectionAction.has_value() ? JFunc_void_SelectionActionEvent_cxx::fromCpp(onSelectionAction.value()) : nullptr);
  }

  // Methods
  void JHybridReadiumViewSpec::goForward() {
    static const auto method = javaClassStatic()->getMethod<void()>("goForward");
    method(_javaPart);
  }
  void JHybridReadiumViewSpec::goBackward() {
    static const auto method = javaClassStatic()->getMethod<void()>("goBackward");
    method(_javaPart);
  }

} // namespace margelo::nitro::readium
