///
/// Preferences.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `Preferences`, backed by a C++ struct.
 */
public typealias Preferences = margelo.nitro.readium.Preferences

public extension Preferences {
  private typealias bridge = margelo.nitro.readium.bridge.swift

  /**
   * Create a new instance of `Preferences`.
   */
  init(backgroundColor: String?, columnCount: String?, fontFamily: String?, fontSize: Double?, fontWeight: Double?, hyphens: Bool?, imageFilter: String?, language: String?, letterSpacing: Double?, ligatures: Bool?, lineHeight: Double?, pageMargins: Double?, paragraphIndent: Double?, paragraphSpacing: Double?, publisherStyles: Bool?, readingProgression: String?, scroll: Bool?, spread: String?, textAlign: String?, textColor: String?, textNormalization: Bool?, theme: String?, typeScale: Double?, verticalText: Bool?, wordSpacing: Double?, merging: Bool?) {
    self.init({ () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = backgroundColor {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = columnCount {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = fontFamily {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = fontSize {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = fontWeight {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = hyphens {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = imageFilter {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = language {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = letterSpacing {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = ligatures {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = lineHeight {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = pageMargins {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = paragraphIndent {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = paragraphSpacing {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = publisherStyles {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = readingProgression {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = scroll {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = spread {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = textAlign {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = textColor {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = textNormalization {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = theme {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = typeScale {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = verticalText {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = wordSpacing {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = merging {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }())
  }

  @inline(__always)
  var backgroundColor: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__backgroundColor) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__backgroundColor)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var columnCount: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__columnCount) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__columnCount)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var fontFamily: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__fontFamily) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__fontFamily)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var fontSize: Double? {
    return self.__fontSize.value
  }
  
  @inline(__always)
  var fontWeight: Double? {
    return self.__fontWeight.value
  }
  
  @inline(__always)
  var hyphens: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__hyphens) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__hyphens)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var imageFilter: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__imageFilter) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__imageFilter)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var language: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__language) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__language)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var letterSpacing: Double? {
    return self.__letterSpacing.value
  }
  
  @inline(__always)
  var ligatures: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__ligatures) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__ligatures)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var lineHeight: Double? {
    return self.__lineHeight.value
  }
  
  @inline(__always)
  var pageMargins: Double? {
    return self.__pageMargins.value
  }
  
  @inline(__always)
  var paragraphIndent: Double? {
    return self.__paragraphIndent.value
  }
  
  @inline(__always)
  var paragraphSpacing: Double? {
    return self.__paragraphSpacing.value
  }
  
  @inline(__always)
  var publisherStyles: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__publisherStyles) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__publisherStyles)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var readingProgression: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__readingProgression) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__readingProgression)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var scroll: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__scroll) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__scroll)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var spread: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__spread) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__spread)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var textAlign: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__textAlign) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__textAlign)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var textColor: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__textColor) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__textColor)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var textNormalization: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__textNormalization) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__textNormalization)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var theme: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__theme) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__theme)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var typeScale: Double? {
    return self.__typeScale.value
  }
  
  @inline(__always)
  var verticalText: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__verticalText) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__verticalText)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var wordSpacing: Double? {
    return self.__wordSpacing.value
  }
  
  @inline(__always)
  var merging: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__merging) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__merging)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
}
