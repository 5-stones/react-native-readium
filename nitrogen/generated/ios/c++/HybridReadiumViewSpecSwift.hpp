///
/// HybridReadiumViewSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#include "HybridReadiumViewSpec.hpp"

// Forward declaration of `HybridReadiumViewSpec_cxx` to properly resolve imports.
namespace NitroReadium { class HybridReadiumViewSpec_cxx; }

// Forward declaration of `ReadiumFile` to properly resolve imports.
namespace margelo::nitro::readium { struct ReadiumFile; }
// Forward declaration of `Locator` to properly resolve imports.
namespace margelo::nitro::readium { struct Locator; }
// Forward declaration of `LocatorLocations` to properly resolve imports.
namespace margelo::nitro::readium { struct LocatorLocations; }
// Forward declaration of `LocatorText` to properly resolve imports.
namespace margelo::nitro::readium { struct LocatorText; }
// Forward declaration of `Preferences` to properly resolve imports.
namespace margelo::nitro::readium { struct Preferences; }
// Forward declaration of `DecorationGroup` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationGroup; }
// Forward declaration of `Decoration` to properly resolve imports.
namespace margelo::nitro::readium { struct Decoration; }
// Forward declaration of `DecorationStyle` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationStyle; }
// Forward declaration of `SelectionAction` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionAction; }
// Forward declaration of `PublicationReadyEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct PublicationReadyEvent; }
// Forward declaration of `Link` to properly resolve imports.
namespace margelo::nitro::readium { struct Link; }
// Forward declaration of `PublicationMetadata` to properly resolve imports.
namespace margelo::nitro::readium { struct PublicationMetadata; }
// Forward declaration of `Accessibility` to properly resolve imports.
namespace margelo::nitro::readium { struct Accessibility; }
// Forward declaration of `AccessibilityCertification` to properly resolve imports.
namespace margelo::nitro::readium { struct AccessibilityCertification; }
// Forward declaration of `Contributor` to properly resolve imports.
namespace margelo::nitro::readium { struct Contributor; }
// Forward declaration of `Subject` to properly resolve imports.
namespace margelo::nitro::readium { struct Subject; }
// Forward declaration of `BelongsTo` to properly resolve imports.
namespace margelo::nitro::readium { struct BelongsTo; }
// Forward declaration of `SeriesInfo` to properly resolve imports.
namespace margelo::nitro::readium { struct SeriesInfo; }
// Forward declaration of `DecorationActivatedEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationActivatedEvent; }
// Forward declaration of `Rect` to properly resolve imports.
namespace margelo::nitro::readium { struct Rect; }
// Forward declaration of `Point` to properly resolve imports.
namespace margelo::nitro::readium { struct Point; }
// Forward declaration of `SelectionEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionEvent; }
// Forward declaration of `SelectionActionEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionActionEvent; }

#include "ReadiumFile.hpp"
#include <string>
#include "Locator.hpp"
#include <optional>
#include "LocatorLocations.hpp"
#include "LocatorText.hpp"
#include "Preferences.hpp"
#include "DecorationGroup.hpp"
#include <vector>
#include "Decoration.hpp"
#include "DecorationStyle.hpp"
#include <unordered_map>
#include "SelectionAction.hpp"
#include <functional>
#include "PublicationReadyEvent.hpp"
#include "Link.hpp"
#include "PublicationMetadata.hpp"
#include "Accessibility.hpp"
#include "AccessibilityCertification.hpp"
#include "Contributor.hpp"
#include "Subject.hpp"
#include "BelongsTo.hpp"
#include "SeriesInfo.hpp"
#include "DecorationActivatedEvent.hpp"
#include "Rect.hpp"
#include "Point.hpp"
#include "SelectionEvent.hpp"
#include "SelectionActionEvent.hpp"

#include "NitroReadium-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::readium {

  /**
   * The C++ part of HybridReadiumViewSpec_cxx.swift.
   *
   * HybridReadiumViewSpecSwift (C++) accesses HybridReadiumViewSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridReadiumViewSpec_cxx can directly inherit from the C++ class HybridReadiumViewSpec
   * to simplify the whole structure and memory management.
   */
  class HybridReadiumViewSpecSwift: public virtual HybridReadiumViewSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridReadiumViewSpecSwift(const NitroReadium::HybridReadiumViewSpec_cxx& swiftPart):
      HybridObject(HybridReadiumViewSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline NitroReadium::HybridReadiumViewSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }
    bool equals(const std::shared_ptr<HybridObject>& other) override {
      if (auto otherCast = std::dynamic_pointer_cast<HybridReadiumViewSpecSwift>(other)) {
        return _swiftPart.equals(otherCast->_swiftPart);
      }
      return false;
    }
    void dispose() noexcept override {
      _swiftPart.dispose();
    }
    std::string toString() override {
      return _swiftPart.toString();
    }

  public:
    // Properties
    inline ReadiumFile getFile() noexcept override {
      return _swiftPart.getFile();
    }
    inline void setFile(const ReadiumFile& file) noexcept override {
      _swiftPart.setFile(std::forward<decltype(file)>(file));
    }
    inline std::optional<Locator> getLocation() noexcept override {
      auto __result = _swiftPart.getLocation();
      return __result;
    }
    inline void setLocation(const std::optional<Locator>& location) noexcept override {
      _swiftPart.setLocation(location);
    }
    inline std::optional<Preferences> getPreferences() noexcept override {
      auto __result = _swiftPart.getPreferences();
      return __result;
    }
    inline void setPreferences(const std::optional<Preferences>& preferences) noexcept override {
      _swiftPart.setPreferences(preferences);
    }
    inline std::optional<std::vector<DecorationGroup>> getDecorations() noexcept override {
      auto __result = _swiftPart.getDecorations();
      return __result;
    }
    inline void setDecorations(const std::optional<std::vector<DecorationGroup>>& decorations) noexcept override {
      _swiftPart.setDecorations(decorations);
    }
    inline std::optional<std::vector<SelectionAction>> getSelectionActions() noexcept override {
      auto __result = _swiftPart.getSelectionActions();
      return __result;
    }
    inline void setSelectionActions(const std::optional<std::vector<SelectionAction>>& selectionActions) noexcept override {
      _swiftPart.setSelectionActions(selectionActions);
    }
    inline std::function<void(const Locator& /* locator */)> getOnLocationChange() noexcept override {
      auto __result = _swiftPart.getOnLocationChange();
      return __result;
    }
    inline void setOnLocationChange(const std::function<void(const Locator& /* locator */)>& onLocationChange) noexcept override {
      _swiftPart.setOnLocationChange(onLocationChange);
    }
    inline std::function<void(const PublicationReadyEvent& /* event */)> getOnPublicationReady() noexcept override {
      auto __result = _swiftPart.getOnPublicationReady();
      return __result;
    }
    inline void setOnPublicationReady(const std::function<void(const PublicationReadyEvent& /* event */)>& onPublicationReady) noexcept override {
      _swiftPart.setOnPublicationReady(onPublicationReady);
    }
    inline std::function<void(const DecorationActivatedEvent& /* event */)> getOnDecorationActivated() noexcept override {
      auto __result = _swiftPart.getOnDecorationActivated();
      return __result;
    }
    inline void setOnDecorationActivated(const std::function<void(const DecorationActivatedEvent& /* event */)>& onDecorationActivated) noexcept override {
      _swiftPart.setOnDecorationActivated(onDecorationActivated);
    }
    inline std::function<void(const SelectionEvent& /* event */)> getOnSelectionChange() noexcept override {
      auto __result = _swiftPart.getOnSelectionChange();
      return __result;
    }
    inline void setOnSelectionChange(const std::function<void(const SelectionEvent& /* event */)>& onSelectionChange) noexcept override {
      _swiftPart.setOnSelectionChange(onSelectionChange);
    }
    inline std::function<void(const SelectionActionEvent& /* event */)> getOnSelectionAction() noexcept override {
      auto __result = _swiftPart.getOnSelectionAction();
      return __result;
    }
    inline void setOnSelectionAction(const std::function<void(const SelectionActionEvent& /* event */)>& onSelectionAction) noexcept override {
      _swiftPart.setOnSelectionAction(onSelectionAction);
    }

  public:
    // Methods
    inline void goForward() override {
      auto __result = _swiftPart.goForward();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void goBackward() override {
      auto __result = _swiftPart.goBackward();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }

  private:
    NitroReadium::HybridReadiumViewSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::readium
