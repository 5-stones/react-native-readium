///
/// NitroReadium-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `AccessibilityCertification` to properly resolve imports.
namespace margelo::nitro::readium { struct AccessibilityCertification; }
// Forward declaration of `Accessibility` to properly resolve imports.
namespace margelo::nitro::readium { struct Accessibility; }
// Forward declaration of `BelongsTo` to properly resolve imports.
namespace margelo::nitro::readium { struct BelongsTo; }
// Forward declaration of `Contributor` to properly resolve imports.
namespace margelo::nitro::readium { struct Contributor; }
// Forward declaration of `DecorationActivatedEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationActivatedEvent; }
// Forward declaration of `DecorationGroup` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationGroup; }
// Forward declaration of `DecorationStyle` to properly resolve imports.
namespace margelo::nitro::readium { struct DecorationStyle; }
// Forward declaration of `Decoration` to properly resolve imports.
namespace margelo::nitro::readium { struct Decoration; }
// Forward declaration of `HybridReadiumViewSpec` to properly resolve imports.
namespace margelo::nitro::readium { class HybridReadiumViewSpec; }
// Forward declaration of `Link` to properly resolve imports.
namespace margelo::nitro::readium { struct Link; }
// Forward declaration of `LocatorLocations` to properly resolve imports.
namespace margelo::nitro::readium { struct LocatorLocations; }
// Forward declaration of `LocatorText` to properly resolve imports.
namespace margelo::nitro::readium { struct LocatorText; }
// Forward declaration of `Locator` to properly resolve imports.
namespace margelo::nitro::readium { struct Locator; }
// Forward declaration of `Point` to properly resolve imports.
namespace margelo::nitro::readium { struct Point; }
// Forward declaration of `Preferences` to properly resolve imports.
namespace margelo::nitro::readium { struct Preferences; }
// Forward declaration of `PublicationMetadata` to properly resolve imports.
namespace margelo::nitro::readium { struct PublicationMetadata; }
// Forward declaration of `PublicationReadyEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct PublicationReadyEvent; }
// Forward declaration of `ReadiumFile` to properly resolve imports.
namespace margelo::nitro::readium { struct ReadiumFile; }
// Forward declaration of `Rect` to properly resolve imports.
namespace margelo::nitro::readium { struct Rect; }
// Forward declaration of `SelectionActionEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionActionEvent; }
// Forward declaration of `SelectionAction` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionAction; }
// Forward declaration of `SelectionEvent` to properly resolve imports.
namespace margelo::nitro::readium { struct SelectionEvent; }
// Forward declaration of `SeriesInfo` to properly resolve imports.
namespace margelo::nitro::readium { struct SeriesInfo; }
// Forward declaration of `Subject` to properly resolve imports.
namespace margelo::nitro::readium { struct Subject; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridReadiumViewSpec_cxx` to properly resolve imports.
namespace NitroReadium { class HybridReadiumViewSpec_cxx; }

// Include C++ defined types
#include "Accessibility.hpp"
#include "AccessibilityCertification.hpp"
#include "BelongsTo.hpp"
#include "Contributor.hpp"
#include "Decoration.hpp"
#include "DecorationActivatedEvent.hpp"
#include "DecorationGroup.hpp"
#include "DecorationStyle.hpp"
#include "HybridReadiumViewSpec.hpp"
#include "Link.hpp"
#include "Locator.hpp"
#include "LocatorLocations.hpp"
#include "LocatorText.hpp"
#include "Point.hpp"
#include "Preferences.hpp"
#include "PublicationMetadata.hpp"
#include "PublicationReadyEvent.hpp"
#include "ReadiumFile.hpp"
#include "Rect.hpp"
#include "SelectionAction.hpp"
#include "SelectionActionEvent.hpp"
#include "SelectionEvent.hpp"
#include "SeriesInfo.hpp"
#include "Subject.hpp"
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::readium::bridge::swift {

  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) noexcept {
    return std::optional<double>(value);
  }
  inline bool has_value_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.has_value();
  }
  inline double get_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<LocatorLocations>
  /**
   * Specialized version of `std::optional<LocatorLocations>`.
   */
  using std__optional_LocatorLocations_ = std::optional<LocatorLocations>;
  inline std::optional<LocatorLocations> create_std__optional_LocatorLocations_(const LocatorLocations& value) noexcept {
    return std::optional<LocatorLocations>(value);
  }
  inline bool has_value_std__optional_LocatorLocations_(const std::optional<LocatorLocations>& optional) noexcept {
    return optional.has_value();
  }
  inline LocatorLocations get_std__optional_LocatorLocations_(const std::optional<LocatorLocations>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<LocatorText>
  /**
   * Specialized version of `std::optional<LocatorText>`.
   */
  using std__optional_LocatorText_ = std::optional<LocatorText>;
  inline std::optional<LocatorText> create_std__optional_LocatorText_(const LocatorText& value) noexcept {
    return std::optional<LocatorText>(value);
  }
  inline bool has_value_std__optional_LocatorText_(const std::optional<LocatorText>& optional) noexcept {
    return optional.has_value();
  }
  inline LocatorText get_std__optional_LocatorText_(const std::optional<LocatorText>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<Locator>
  /**
   * Specialized version of `std::optional<Locator>`.
   */
  using std__optional_Locator_ = std::optional<Locator>;
  inline std::optional<Locator> create_std__optional_Locator_(const Locator& value) noexcept {
    return std::optional<Locator>(value);
  }
  inline bool has_value_std__optional_Locator_(const std::optional<Locator>& optional) noexcept {
    return optional.has_value();
  }
  inline Locator get_std__optional_Locator_(const std::optional<Locator>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<ReadiumFile>
  /**
   * Specialized version of `std::optional<ReadiumFile>`.
   */
  using std__optional_ReadiumFile_ = std::optional<ReadiumFile>;
  inline std::optional<ReadiumFile> create_std__optional_ReadiumFile_(const ReadiumFile& value) noexcept {
    return std::optional<ReadiumFile>(value);
  }
  inline bool has_value_std__optional_ReadiumFile_(const std::optional<ReadiumFile>& optional) noexcept {
    return optional.has_value();
  }
  inline ReadiumFile get_std__optional_ReadiumFile_(const std::optional<ReadiumFile>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) noexcept {
    return std::optional<bool>(value);
  }
  inline bool has_value_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.has_value();
  }
  inline bool get_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<Preferences>
  /**
   * Specialized version of `std::optional<Preferences>`.
   */
  using std__optional_Preferences_ = std::optional<Preferences>;
  inline std::optional<Preferences> create_std__optional_Preferences_(const Preferences& value) noexcept {
    return std::optional<Preferences>(value);
  }
  inline bool has_value_std__optional_Preferences_(const std::optional<Preferences>& optional) noexcept {
    return optional.has_value();
  }
  inline Preferences get_std__optional_Preferences_(const std::optional<Preferences>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::unordered_map<std::string, std::string>
  /**
   * Specialized version of `std::unordered_map<std::string, std::string>`.
   */
  using std__unordered_map_std__string__std__string_ = std::unordered_map<std::string, std::string>;
  inline std::unordered_map<std::string, std::string> create_std__unordered_map_std__string__std__string_(size_t size) noexcept {
    std::unordered_map<std::string, std::string> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__std__string__keys(const std__unordered_map_std__string__std__string_& map) noexcept {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  inline std::string get_std__unordered_map_std__string__std__string__value(const std__unordered_map_std__string__std__string_& map, const std::string& key) noexcept {
    return map.find(key)->second;
  }
  inline void emplace_std__unordered_map_std__string__std__string_(std__unordered_map_std__string__std__string_& map, const std::string& key, const std::string& value) noexcept {
    map.emplace(key, value);
  }
  
  // pragma MARK: std::optional<std::unordered_map<std::string, std::string>>
  /**
   * Specialized version of `std::optional<std::unordered_map<std::string, std::string>>`.
   */
  using std__optional_std__unordered_map_std__string__std__string__ = std::optional<std::unordered_map<std::string, std::string>>;
  inline std::optional<std::unordered_map<std::string, std::string>> create_std__optional_std__unordered_map_std__string__std__string__(const std::unordered_map<std::string, std::string>& value) noexcept {
    return std::optional<std::unordered_map<std::string, std::string>>(value);
  }
  inline bool has_value_std__optional_std__unordered_map_std__string__std__string__(const std::optional<std::unordered_map<std::string, std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::unordered_map<std::string, std::string> get_std__optional_std__unordered_map_std__string__std__string__(const std::optional<std::unordered_map<std::string, std::string>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::vector<Decoration>
  /**
   * Specialized version of `std::vector<Decoration>`.
   */
  using std__vector_Decoration_ = std::vector<Decoration>;
  inline std::vector<Decoration> create_std__vector_Decoration_(size_t size) noexcept {
    std::vector<Decoration> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<DecorationGroup>
  /**
   * Specialized version of `std::vector<DecorationGroup>`.
   */
  using std__vector_DecorationGroup_ = std::vector<DecorationGroup>;
  inline std::vector<DecorationGroup> create_std__vector_DecorationGroup_(size_t size) noexcept {
    std::vector<DecorationGroup> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<DecorationGroup>>
  /**
   * Specialized version of `std::optional<std::vector<DecorationGroup>>`.
   */
  using std__optional_std__vector_DecorationGroup__ = std::optional<std::vector<DecorationGroup>>;
  inline std::optional<std::vector<DecorationGroup>> create_std__optional_std__vector_DecorationGroup__(const std::vector<DecorationGroup>& value) noexcept {
    return std::optional<std::vector<DecorationGroup>>(value);
  }
  inline bool has_value_std__optional_std__vector_DecorationGroup__(const std::optional<std::vector<DecorationGroup>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<DecorationGroup> get_std__optional_std__vector_DecorationGroup__(const std::optional<std::vector<DecorationGroup>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::vector<SelectionAction>
  /**
   * Specialized version of `std::vector<SelectionAction>`.
   */
  using std__vector_SelectionAction_ = std::vector<SelectionAction>;
  inline std::vector<SelectionAction> create_std__vector_SelectionAction_(size_t size) noexcept {
    std::vector<SelectionAction> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<SelectionAction>>
  /**
   * Specialized version of `std::optional<std::vector<SelectionAction>>`.
   */
  using std__optional_std__vector_SelectionAction__ = std::optional<std::vector<SelectionAction>>;
  inline std::optional<std::vector<SelectionAction>> create_std__optional_std__vector_SelectionAction__(const std::vector<SelectionAction>& value) noexcept {
    return std::optional<std::vector<SelectionAction>>(value);
  }
  inline bool has_value_std__optional_std__vector_SelectionAction__(const std::optional<std::vector<SelectionAction>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<SelectionAction> get_std__optional_std__vector_SelectionAction__(const std::optional<std::vector<SelectionAction>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::function<void(const Locator& /* locator */)>
  /**
   * Specialized version of `std::function<void(const Locator&)>`.
   */
  using Func_void_Locator = std::function<void(const Locator& /* locator */)>;
  /**
   * Wrapper class for a `std::function<void(const Locator& / * locator * /)>`, this can be used from Swift.
   */
  class Func_void_Locator_Wrapper final {
  public:
    explicit Func_void_Locator_Wrapper(std::function<void(const Locator& /* locator */)>&& func): _function(std::make_unique<std::function<void(const Locator& /* locator */)>>(std::move(func))) {}
    inline void call(Locator locator) const noexcept {
      _function->operator()(locator);
    }
  private:
    std::unique_ptr<std::function<void(const Locator& /* locator */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_Locator create_Func_void_Locator(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Locator_Wrapper wrap_Func_void_Locator(Func_void_Locator value) noexcept {
    return Func_void_Locator_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const Locator& /* locator */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const Locator& / * locator * /)>>`.
   */
  using std__optional_std__function_void_const_Locator_____locator______ = std::optional<std::function<void(const Locator& /* locator */)>>;
  inline std::optional<std::function<void(const Locator& /* locator */)>> create_std__optional_std__function_void_const_Locator_____locator______(const std::function<void(const Locator& /* locator */)>& value) noexcept {
    return std::optional<std::function<void(const Locator& /* locator */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_Locator_____locator______(const std::optional<std::function<void(const Locator& /* locator */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const Locator& /* locator */)> get_std__optional_std__function_void_const_Locator_____locator______(const std::optional<std::function<void(const Locator& /* locator */)>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<std::string>>
  /**
   * Specialized version of `std::optional<std::vector<std::string>>`.
   */
  using std__optional_std__vector_std__string__ = std::optional<std::vector<std::string>>;
  inline std::optional<std::vector<std::string>> create_std__optional_std__vector_std__string__(const std::vector<std::string>& value) noexcept {
    return std::optional<std::vector<std::string>>(value);
  }
  inline bool has_value_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<std::string> get_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::vector<Link>
  /**
   * Specialized version of `std::vector<Link>`.
   */
  using std__vector_Link_ = std::vector<Link>;
  inline std::vector<Link> create_std__vector_Link_(size_t size) noexcept {
    std::vector<Link> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<Locator>
  /**
   * Specialized version of `std::vector<Locator>`.
   */
  using std__vector_Locator_ = std::vector<Locator>;
  inline std::vector<Locator> create_std__vector_Locator_(size_t size) noexcept {
    std::vector<Locator> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<AccessibilityCertification>
  /**
   * Specialized version of `std::optional<AccessibilityCertification>`.
   */
  using std__optional_AccessibilityCertification_ = std::optional<AccessibilityCertification>;
  inline std::optional<AccessibilityCertification> create_std__optional_AccessibilityCertification_(const AccessibilityCertification& value) noexcept {
    return std::optional<AccessibilityCertification>(value);
  }
  inline bool has_value_std__optional_AccessibilityCertification_(const std::optional<AccessibilityCertification>& optional) noexcept {
    return optional.has_value();
  }
  inline AccessibilityCertification get_std__optional_AccessibilityCertification_(const std::optional<AccessibilityCertification>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<Accessibility>
  /**
   * Specialized version of `std::optional<Accessibility>`.
   */
  using std__optional_Accessibility_ = std::optional<Accessibility>;
  inline std::optional<Accessibility> create_std__optional_Accessibility_(const Accessibility& value) noexcept {
    return std::optional<Accessibility>(value);
  }
  inline bool has_value_std__optional_Accessibility_(const std::optional<Accessibility>& optional) noexcept {
    return optional.has_value();
  }
  inline Accessibility get_std__optional_Accessibility_(const std::optional<Accessibility>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::vector<Contributor>
  /**
   * Specialized version of `std::vector<Contributor>`.
   */
  using std__vector_Contributor_ = std::vector<Contributor>;
  inline std::vector<Contributor> create_std__vector_Contributor_(size_t size) noexcept {
    std::vector<Contributor> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<Contributor>>
  /**
   * Specialized version of `std::optional<std::vector<Contributor>>`.
   */
  using std__optional_std__vector_Contributor__ = std::optional<std::vector<Contributor>>;
  inline std::optional<std::vector<Contributor>> create_std__optional_std__vector_Contributor__(const std::vector<Contributor>& value) noexcept {
    return std::optional<std::vector<Contributor>>(value);
  }
  inline bool has_value_std__optional_std__vector_Contributor__(const std::optional<std::vector<Contributor>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<Contributor> get_std__optional_std__vector_Contributor__(const std::optional<std::vector<Contributor>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::vector<Subject>
  /**
   * Specialized version of `std::vector<Subject>`.
   */
  using std__vector_Subject_ = std::vector<Subject>;
  inline std::vector<Subject> create_std__vector_Subject_(size_t size) noexcept {
    std::vector<Subject> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<Subject>>
  /**
   * Specialized version of `std::optional<std::vector<Subject>>`.
   */
  using std__optional_std__vector_Subject__ = std::optional<std::vector<Subject>>;
  inline std::optional<std::vector<Subject>> create_std__optional_std__vector_Subject__(const std::vector<Subject>& value) noexcept {
    return std::optional<std::vector<Subject>>(value);
  }
  inline bool has_value_std__optional_std__vector_Subject__(const std::optional<std::vector<Subject>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<Subject> get_std__optional_std__vector_Subject__(const std::optional<std::vector<Subject>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::vector<SeriesInfo>
  /**
   * Specialized version of `std::vector<SeriesInfo>`.
   */
  using std__vector_SeriesInfo_ = std::vector<SeriesInfo>;
  inline std::vector<SeriesInfo> create_std__vector_SeriesInfo_(size_t size) noexcept {
    std::vector<SeriesInfo> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<SeriesInfo>>
  /**
   * Specialized version of `std::optional<std::vector<SeriesInfo>>`.
   */
  using std__optional_std__vector_SeriesInfo__ = std::optional<std::vector<SeriesInfo>>;
  inline std::optional<std::vector<SeriesInfo>> create_std__optional_std__vector_SeriesInfo__(const std::vector<SeriesInfo>& value) noexcept {
    return std::optional<std::vector<SeriesInfo>>(value);
  }
  inline bool has_value_std__optional_std__vector_SeriesInfo__(const std::optional<std::vector<SeriesInfo>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<SeriesInfo> get_std__optional_std__vector_SeriesInfo__(const std::optional<std::vector<SeriesInfo>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<BelongsTo>
  /**
   * Specialized version of `std::optional<BelongsTo>`.
   */
  using std__optional_BelongsTo_ = std::optional<BelongsTo>;
  inline std::optional<BelongsTo> create_std__optional_BelongsTo_(const BelongsTo& value) noexcept {
    return std::optional<BelongsTo>(value);
  }
  inline bool has_value_std__optional_BelongsTo_(const std::optional<BelongsTo>& optional) noexcept {
    return optional.has_value();
  }
  inline BelongsTo get_std__optional_BelongsTo_(const std::optional<BelongsTo>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::function<void(const PublicationReadyEvent& /* event */)>
  /**
   * Specialized version of `std::function<void(const PublicationReadyEvent&)>`.
   */
  using Func_void_PublicationReadyEvent = std::function<void(const PublicationReadyEvent& /* event */)>;
  /**
   * Wrapper class for a `std::function<void(const PublicationReadyEvent& / * event * /)>`, this can be used from Swift.
   */
  class Func_void_PublicationReadyEvent_Wrapper final {
  public:
    explicit Func_void_PublicationReadyEvent_Wrapper(std::function<void(const PublicationReadyEvent& /* event */)>&& func): _function(std::make_unique<std::function<void(const PublicationReadyEvent& /* event */)>>(std::move(func))) {}
    inline void call(PublicationReadyEvent event) const noexcept {
      _function->operator()(event);
    }
  private:
    std::unique_ptr<std::function<void(const PublicationReadyEvent& /* event */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_PublicationReadyEvent create_Func_void_PublicationReadyEvent(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_PublicationReadyEvent_Wrapper wrap_Func_void_PublicationReadyEvent(Func_void_PublicationReadyEvent value) noexcept {
    return Func_void_PublicationReadyEvent_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const PublicationReadyEvent& /* event */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const PublicationReadyEvent& / * event * /)>>`.
   */
  using std__optional_std__function_void_const_PublicationReadyEvent_____event______ = std::optional<std::function<void(const PublicationReadyEvent& /* event */)>>;
  inline std::optional<std::function<void(const PublicationReadyEvent& /* event */)>> create_std__optional_std__function_void_const_PublicationReadyEvent_____event______(const std::function<void(const PublicationReadyEvent& /* event */)>& value) noexcept {
    return std::optional<std::function<void(const PublicationReadyEvent& /* event */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_PublicationReadyEvent_____event______(const std::optional<std::function<void(const PublicationReadyEvent& /* event */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const PublicationReadyEvent& /* event */)> get_std__optional_std__function_void_const_PublicationReadyEvent_____event______(const std::optional<std::function<void(const PublicationReadyEvent& /* event */)>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<Rect>
  /**
   * Specialized version of `std::optional<Rect>`.
   */
  using std__optional_Rect_ = std::optional<Rect>;
  inline std::optional<Rect> create_std__optional_Rect_(const Rect& value) noexcept {
    return std::optional<Rect>(value);
  }
  inline bool has_value_std__optional_Rect_(const std::optional<Rect>& optional) noexcept {
    return optional.has_value();
  }
  inline Rect get_std__optional_Rect_(const std::optional<Rect>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::optional<Point>
  /**
   * Specialized version of `std::optional<Point>`.
   */
  using std__optional_Point_ = std::optional<Point>;
  inline std::optional<Point> create_std__optional_Point_(const Point& value) noexcept {
    return std::optional<Point>(value);
  }
  inline bool has_value_std__optional_Point_(const std::optional<Point>& optional) noexcept {
    return optional.has_value();
  }
  inline Point get_std__optional_Point_(const std::optional<Point>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::function<void(const DecorationActivatedEvent& /* event */)>
  /**
   * Specialized version of `std::function<void(const DecorationActivatedEvent&)>`.
   */
  using Func_void_DecorationActivatedEvent = std::function<void(const DecorationActivatedEvent& /* event */)>;
  /**
   * Wrapper class for a `std::function<void(const DecorationActivatedEvent& / * event * /)>`, this can be used from Swift.
   */
  class Func_void_DecorationActivatedEvent_Wrapper final {
  public:
    explicit Func_void_DecorationActivatedEvent_Wrapper(std::function<void(const DecorationActivatedEvent& /* event */)>&& func): _function(std::make_unique<std::function<void(const DecorationActivatedEvent& /* event */)>>(std::move(func))) {}
    inline void call(DecorationActivatedEvent event) const noexcept {
      _function->operator()(event);
    }
  private:
    std::unique_ptr<std::function<void(const DecorationActivatedEvent& /* event */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_DecorationActivatedEvent create_Func_void_DecorationActivatedEvent(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_DecorationActivatedEvent_Wrapper wrap_Func_void_DecorationActivatedEvent(Func_void_DecorationActivatedEvent value) noexcept {
    return Func_void_DecorationActivatedEvent_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const DecorationActivatedEvent& / * event * /)>>`.
   */
  using std__optional_std__function_void_const_DecorationActivatedEvent_____event______ = std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>;
  inline std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>> create_std__optional_std__function_void_const_DecorationActivatedEvent_____event______(const std::function<void(const DecorationActivatedEvent& /* event */)>& value) noexcept {
    return std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_DecorationActivatedEvent_____event______(const std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const DecorationActivatedEvent& /* event */)> get_std__optional_std__function_void_const_DecorationActivatedEvent_____event______(const std::optional<std::function<void(const DecorationActivatedEvent& /* event */)>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::function<void(const SelectionEvent& /* event */)>
  /**
   * Specialized version of `std::function<void(const SelectionEvent&)>`.
   */
  using Func_void_SelectionEvent = std::function<void(const SelectionEvent& /* event */)>;
  /**
   * Wrapper class for a `std::function<void(const SelectionEvent& / * event * /)>`, this can be used from Swift.
   */
  class Func_void_SelectionEvent_Wrapper final {
  public:
    explicit Func_void_SelectionEvent_Wrapper(std::function<void(const SelectionEvent& /* event */)>&& func): _function(std::make_unique<std::function<void(const SelectionEvent& /* event */)>>(std::move(func))) {}
    inline void call(SelectionEvent event) const noexcept {
      _function->operator()(event);
    }
  private:
    std::unique_ptr<std::function<void(const SelectionEvent& /* event */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_SelectionEvent create_Func_void_SelectionEvent(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_SelectionEvent_Wrapper wrap_Func_void_SelectionEvent(Func_void_SelectionEvent value) noexcept {
    return Func_void_SelectionEvent_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const SelectionEvent& /* event */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const SelectionEvent& / * event * /)>>`.
   */
  using std__optional_std__function_void_const_SelectionEvent_____event______ = std::optional<std::function<void(const SelectionEvent& /* event */)>>;
  inline std::optional<std::function<void(const SelectionEvent& /* event */)>> create_std__optional_std__function_void_const_SelectionEvent_____event______(const std::function<void(const SelectionEvent& /* event */)>& value) noexcept {
    return std::optional<std::function<void(const SelectionEvent& /* event */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_SelectionEvent_____event______(const std::optional<std::function<void(const SelectionEvent& /* event */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const SelectionEvent& /* event */)> get_std__optional_std__function_void_const_SelectionEvent_____event______(const std::optional<std::function<void(const SelectionEvent& /* event */)>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::function<void(const SelectionActionEvent& /* event */)>
  /**
   * Specialized version of `std::function<void(const SelectionActionEvent&)>`.
   */
  using Func_void_SelectionActionEvent = std::function<void(const SelectionActionEvent& /* event */)>;
  /**
   * Wrapper class for a `std::function<void(const SelectionActionEvent& / * event * /)>`, this can be used from Swift.
   */
  class Func_void_SelectionActionEvent_Wrapper final {
  public:
    explicit Func_void_SelectionActionEvent_Wrapper(std::function<void(const SelectionActionEvent& /* event */)>&& func): _function(std::make_unique<std::function<void(const SelectionActionEvent& /* event */)>>(std::move(func))) {}
    inline void call(SelectionActionEvent event) const noexcept {
      _function->operator()(event);
    }
  private:
    std::unique_ptr<std::function<void(const SelectionActionEvent& /* event */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_SelectionActionEvent create_Func_void_SelectionActionEvent(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_SelectionActionEvent_Wrapper wrap_Func_void_SelectionActionEvent(Func_void_SelectionActionEvent value) noexcept {
    return Func_void_SelectionActionEvent_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const SelectionActionEvent& /* event */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const SelectionActionEvent& / * event * /)>>`.
   */
  using std__optional_std__function_void_const_SelectionActionEvent_____event______ = std::optional<std::function<void(const SelectionActionEvent& /* event */)>>;
  inline std::optional<std::function<void(const SelectionActionEvent& /* event */)>> create_std__optional_std__function_void_const_SelectionActionEvent_____event______(const std::function<void(const SelectionActionEvent& /* event */)>& value) noexcept {
    return std::optional<std::function<void(const SelectionActionEvent& /* event */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_SelectionActionEvent_____event______(const std::optional<std::function<void(const SelectionActionEvent& /* event */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const SelectionActionEvent& /* event */)> get_std__optional_std__function_void_const_SelectionActionEvent_____event______(const std::optional<std::function<void(const SelectionActionEvent& /* event */)>>& optional) noexcept {
    return optional.value();
  }
  
  // pragma MARK: std::shared_ptr<HybridReadiumViewSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridReadiumViewSpec>`.
   */
  using std__shared_ptr_HybridReadiumViewSpec_ = std::shared_ptr<HybridReadiumViewSpec>;
  std::shared_ptr<HybridReadiumViewSpec> create_std__shared_ptr_HybridReadiumViewSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridReadiumViewSpec_(std__shared_ptr_HybridReadiumViewSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridReadiumViewSpec>
  using std__weak_ptr_HybridReadiumViewSpec_ = std::weak_ptr<HybridReadiumViewSpec>;
  inline std__weak_ptr_HybridReadiumViewSpec_ weakify_std__shared_ptr_HybridReadiumViewSpec_(const std::shared_ptr<HybridReadiumViewSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }

} // namespace margelo::nitro::readium::bridge::swift
