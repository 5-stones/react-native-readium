///
/// Preferences.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/JSIHelpers.hpp>)
#include <NitroModules/JSIHelpers.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/PropNameIDCache.hpp>)
#include <NitroModules/PropNameIDCache.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif



#include <string>
#include <optional>

namespace margelo::nitro::readium {

  /**
   * A struct which can be represented as a JavaScript object (Preferences).
   */
  struct Preferences final {
  public:
    std::optional<std::string> backgroundColor     SWIFT_PRIVATE;
    std::optional<std::string> columnCount     SWIFT_PRIVATE;
    std::optional<std::string> fontFamily     SWIFT_PRIVATE;
    std::optional<double> fontSize     SWIFT_PRIVATE;
    std::optional<double> fontWeight     SWIFT_PRIVATE;
    std::optional<bool> hyphens     SWIFT_PRIVATE;
    std::optional<std::string> imageFilter     SWIFT_PRIVATE;
    std::optional<std::string> language     SWIFT_PRIVATE;
    std::optional<double> letterSpacing     SWIFT_PRIVATE;
    std::optional<bool> ligatures     SWIFT_PRIVATE;
    std::optional<double> lineHeight     SWIFT_PRIVATE;
    std::optional<double> pageMargins     SWIFT_PRIVATE;
    std::optional<double> paragraphIndent     SWIFT_PRIVATE;
    std::optional<double> paragraphSpacing     SWIFT_PRIVATE;
    std::optional<bool> publisherStyles     SWIFT_PRIVATE;
    std::optional<std::string> readingProgression     SWIFT_PRIVATE;
    std::optional<bool> scroll     SWIFT_PRIVATE;
    std::optional<std::string> spread     SWIFT_PRIVATE;
    std::optional<std::string> textAlign     SWIFT_PRIVATE;
    std::optional<std::string> textColor     SWIFT_PRIVATE;
    std::optional<bool> textNormalization     SWIFT_PRIVATE;
    std::optional<std::string> theme     SWIFT_PRIVATE;
    std::optional<double> typeScale     SWIFT_PRIVATE;
    std::optional<bool> verticalText     SWIFT_PRIVATE;
    std::optional<double> wordSpacing     SWIFT_PRIVATE;
    std::optional<bool> merging     SWIFT_PRIVATE;

  public:
    Preferences() = default;
    explicit Preferences(std::optional<std::string> backgroundColor, std::optional<std::string> columnCount, std::optional<std::string> fontFamily, std::optional<double> fontSize, std::optional<double> fontWeight, std::optional<bool> hyphens, std::optional<std::string> imageFilter, std::optional<std::string> language, std::optional<double> letterSpacing, std::optional<bool> ligatures, std::optional<double> lineHeight, std::optional<double> pageMargins, std::optional<double> paragraphIndent, std::optional<double> paragraphSpacing, std::optional<bool> publisherStyles, std::optional<std::string> readingProgression, std::optional<bool> scroll, std::optional<std::string> spread, std::optional<std::string> textAlign, std::optional<std::string> textColor, std::optional<bool> textNormalization, std::optional<std::string> theme, std::optional<double> typeScale, std::optional<bool> verticalText, std::optional<double> wordSpacing, std::optional<bool> merging): backgroundColor(backgroundColor), columnCount(columnCount), fontFamily(fontFamily), fontSize(fontSize), fontWeight(fontWeight), hyphens(hyphens), imageFilter(imageFilter), language(language), letterSpacing(letterSpacing), ligatures(ligatures), lineHeight(lineHeight), pageMargins(pageMargins), paragraphIndent(paragraphIndent), paragraphSpacing(paragraphSpacing), publisherStyles(publisherStyles), readingProgression(readingProgression), scroll(scroll), spread(spread), textAlign(textAlign), textColor(textColor), textNormalization(textNormalization), theme(theme), typeScale(typeScale), verticalText(verticalText), wordSpacing(wordSpacing), merging(merging) {}

  public:
    friend bool operator==(const Preferences& lhs, const Preferences& rhs) = default;
  };

} // namespace margelo::nitro::readium

namespace margelo::nitro {

  // C++ Preferences <> JS Preferences (object)
  template <>
  struct JSIConverter<margelo::nitro::readium::Preferences> final {
    static inline margelo::nitro::readium::Preferences fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return margelo::nitro::readium::Preferences(
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "backgroundColor"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "columnCount"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "fontFamily"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "fontSize"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "fontWeight"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "hyphens"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "imageFilter"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "language"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "letterSpacing"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "ligatures"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "lineHeight"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "pageMargins"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "paragraphIndent"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "paragraphSpacing"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "publisherStyles"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "readingProgression"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "scroll"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "spread"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "textAlign"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "textColor"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "textNormalization"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "theme"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "typeScale"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "verticalText"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "wordSpacing"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "merging")))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const margelo::nitro::readium::Preferences& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "backgroundColor"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.backgroundColor));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "columnCount"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.columnCount));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "fontFamily"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.fontFamily));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "fontSize"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.fontSize));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "fontWeight"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.fontWeight));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "hyphens"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.hyphens));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "imageFilter"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.imageFilter));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "language"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.language));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "letterSpacing"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.letterSpacing));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "ligatures"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.ligatures));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "lineHeight"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.lineHeight));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "pageMargins"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.pageMargins));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "paragraphIndent"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.paragraphIndent));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "paragraphSpacing"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.paragraphSpacing));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "publisherStyles"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.publisherStyles));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "readingProgression"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.readingProgression));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "scroll"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.scroll));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "spread"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.spread));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "textAlign"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.textAlign));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "textColor"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.textColor));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "textNormalization"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.textNormalization));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "theme"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.theme));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "typeScale"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.typeScale));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "verticalText"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.verticalText));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "wordSpacing"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.wordSpacing));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "merging"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.merging));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!nitro::isPlainObject(runtime, obj)) {
        return false;
      }
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "backgroundColor")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "columnCount")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "fontFamily")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "fontSize")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "fontWeight")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "hyphens")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "imageFilter")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "language")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "letterSpacing")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "ligatures")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "lineHeight")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "pageMargins")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "paragraphIndent")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "paragraphSpacing")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "publisherStyles")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "readingProgression")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "scroll")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "spread")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "textAlign")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "textColor")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "textNormalization")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "theme")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "typeScale")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "verticalText")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "wordSpacing")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "merging")))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
